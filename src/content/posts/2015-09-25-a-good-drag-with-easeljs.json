{"content":"<p>I have been checking out EaselJS lately as a tool to streamline some of the tasks of managing objects drawn on a canvas. When I looked at the EaselJS site&#39;s examples for dragging, I saw that dragged objects were getting recentered relative to the mouse coordinates, causing the object to jump a little when the mouse first moved. After looking through the docs a little further, I realized this was a pretty easy thing to fix, and it certainly isn&#39;t a bug. For more information on EaselJS and the whole CreateJS suite, check out <a href=\"http://createjs.com/\">the CreateJS site</a>.</p>\n<h3 id=\"overview\">Overview</h3>\n<ol>\n<li><a href=\"#easeljs-mouse-events\">Mouse events in EaselJS.</a></li>\n<li><a href=\"#a-basic-drag\">Basic dragging example, with recentering.</a></li>\n<li><a href=\"#a-better-drag\">Better dragging, without recentering.</a></li>\n</ol>\n<h3 id=\"easeljs-mouse-events\">EaselJS Mouse Events</h3>\n<p>Objects created on the canvas with EaselJS can utilize the standard JavaScript events. In addition, there are a few unique events that EaselJS makes available, a couple of which &mdash; <code>pushmove</code> and <code>pushup</code> &mdash; are particularly relevant for dragging. The <code>pushmove</code> event is fired every time the mouse moves while a user has the mouse engaged (clicked down) over an object. Mouse events in EaselJS have <code>stageX</code> and <code>stageY</code> properties which indicate the coordinates within the canvas area (in EaselJS, the canvas area getting drawn on is a <code>stage</code> object). We can easily implement a drag by using <code>stageX</code> and <code>stageY</code> to update the position of an object during a related <code>pushmove</code> event.</p>\n<h3 id=\"a-basic-drag\">A Basic Drag</h3>\n<p>I&#39;m not really going to go over the set-up of the canvas and easelJS <code>stage</code>. Here is one way to go about setting up some draggable objects in EaselJS:</p>\n<pre><code>// get a reference to the canvas element on the page, and\n// use this to initialize a createJS &#39;stage&#39;, which will\n// hold any easelJS objects we make\nvar canvas = document.getElementById(&#39;canvas&#39;),\n    stage = new createjs.Stage(canvas),\n\n    // the circles we&#39;ll make\n    circleA, circleB;\n\n// we&#39;ll make our own Circle object, which uses the\n// createjs.Shape object as its prototype\nCircle.prototype = new createjs.Shape();\n\n// use Circle to create a new instance of the Circle object\nCircle.constructor = Circle;\n\n// the Circle constructor\nfunction Circle(xpos, ypos, color, radius) {\n  // call super constructor, ensures proper binding of &#39;this&#39;\n  // such that new instances of Circle are not bound to each other\n  createjs.Shape.call( this );\n\n  // draw the circle using the arguments passed in\n  this.graphics.beginFill(color);\n  this.graphics.drawCircle(0, 0, radius);\n  this.x = xpos;\n  this.y = ypos;\n  this.graphics.endFill();\n\n  // assign handlers\n  this.on(&#39;pressmove&#39;, this.handlePressmove);\n}\n\n// handler for the movement of the mouse while it is\n// engaged over an instance of the Circle object\nCircle.prototype.handlePressmove = function(e) {\n  // update the X and Y coordinates of the object using the\n  // X and Y coordinates of the mouse relative to the stage area\n  this.x = e.stageX;\n  this.y = e.stageY;\n\n  // update the stage so that the object actually moves!\n  stage.update();\n};\n\n// create a couple of instances of the Circle object\nvar circleA = new Circle(40, 40, &#39;#000&#39;, 40);\nvar circleB = new Circle(100, 100, &#39;orange&#39;, 30);\n\n// add these objects to the stage\nstage.addChild(circleA);\nstage.addChild(circleB);\n\n// draw the new objects on the stage\nstage.update();</code></pre>\n<p>The important part of the code here is the <code>handlePressmove</code> method. What the problem boils down to is this:</p>\n<ol>\n<li>Before a circle object is clicked, it has set X and Y coordinates (<code>this.x</code> and <code>this.y</code>). In the case of a circle, those coordinates are for the center point.</li>\n<li>On click, <code>this.x</code> and <code>this.y</code> remain fixed.</li>\n<li>When the clicked cursor moves, the <code>handlePressmove</code> method resets <code>this.x</code> and <code>this.y</code> to wherever the cursor happens to be within the easelJS stage using the <code>stageX</code> and <code>stageY</code> properties of the associated event. The center of the circle object will jump to those cursor coordinates (unless the user happened to click on the exact center of the circle before dragging).</li>\n</ol>\n<p>A fix for this jump is to calculate the offset of the cursor relative to the center point of the object, and use this offset to adjust <code>this.x</code> and <code>this.y</code> when the cursor moves. The local <code>localX</code> and <code>localY</code> properties of an EaselJS mouse event give the mouse location relative to the coordinate system of the object being interacted with, rather than relative to the canvas or stage. These properties are available during the <code>pressmove</code> event. However, <code>localX</code>,<code>localY</code> update to 0,0 (the circle&#39;s center point) as soon as the object moves. What we need is to capture the <code>localX</code> and <code>localY</code> of the cursor on the object when the <code>mousedown</code> occurs.</p>\n<h3 id=\"a-better-drag\">A Better Drag</h3>\n<p>To get a better drag, we utilize the <code>mousedown</code> event to capture <code>localX</code> and <code>localY</code> coordinates for the cursor (cursor coordinates relative to the center point of the object being clicked), then use these coordinates to calculate an offset for the update to <code>this.x</code> and <code>this.y</code> done in the <code>pressmove</code> handler. The majority of the code remains the same as above:</p>\n<pre><code>// the Circle constructor\nfunction Circle(xpos, ypos, color, radius) {\n  // call super constructor ...\n  // draw the circle ...\n\n  this.localX = xpos;\n  this.localY = ypos;\n\n  // assign handlers\n  this.on(&#39;mousedown&#39;, this.handleMousedown);\n  this.on(&#39;pressmove&#39;, this.handlePressmove);\n}\n\nCircle.prototype.handleMousedown = function(e) {\n  this.localX = e.localX;\n  this.localY = e.localY;\n};\n\nCircle.prototype.handlePressmove = function(e) {\n  this.x = e.stageX - this.localX;\n  this.y = e.stageY - this.localY;\n\n  stage.update();\n};</code></pre>\n<p>Now when the mouse moves during a <code>pressmove</code> event, the update to the object&#39;s x and y coordinates are offset by the coordinates of where the object was clicked. No more jump on drag.</p>","meta":{"year":"2015","month":"09","day":"25","filename":"a-good-drag-with-easeljs","title":"A Good Drag","date":"2015-09-25T12:00:00.000Z","desc":"Getting better dragging on canvas objects with EaselJS.","tags":["EaselJS","animation","dragging","JavaScript","canvas","HTML5"]}}