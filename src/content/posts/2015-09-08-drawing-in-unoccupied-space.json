{"content":"<p>I wanted to draw a series of randomly positioned words with variable size on a canvas element, such that the words wouldn’t overlap on the canvas. Now, I knew there was probably (definitely) a really smart way to do this, but I wanted to go through and see what I could come up with myself. So fair warning, this probably (definitely) isn’t the best way to go about doing this.</p>\n<h3 id=\"the-overview\">The Overview</h3>\n<ol>\n<li>Go through each word and measure its dimensions as it will appear on the canvas, storing its width and height.</li>\n<li>Randomly select a position for the largest word.</li>\n<li>Randomly select a position for the next largest word. When drawn on the canvas, if the area occupied by this word overlaps with the last word drawn, find a new position from which to draw.</li>\n<li>Repeat the selection process for all words.</li>\n<li>Draw the words.</li>\n</ol>\n<h3 id=\"measuring-words\">Measuring Words</h3>\n<p>The first challenge was to measure text as drawn on the canvas. The canvas API has a handy native method for measuring text width, <code>measureText</code>. However, there is no such method for measuring text height. Because fonts vary wildly in character height and character position relative to the baseline, there wasn’t an easy way to measure height given the characters in a string. Figuring this out seemed way too complicated, so I went the grossly oversimplified route and just used the font px size that would be used when drawing the word to get a vague estimation of word height.</p>\n<p>A string’s width on the canvas can be determined without actually drawing it onto the canvas. Once a 2d <code>context</code> has been established, string width is measured by first setting the <code>context.font</code> to the desired font size and font family, then passing the string of interest to the <code>measureText</code> method. In this case, <code>measureText</code> was called for a bunch of word objects in a collection, and the result for each string was stored in the respective object.</p>\n<pre><code>var canvas = document.getElementById(&#39;myCanvas&#39;);\nvar context = canvas.getContext(&#39;2d&#39;);\n\n// an object that will later be defined and used to draw the canvas\nvar canvasDimensions = {};\n\n// the collection of word objects, built elsewhere...\nvar wordList = [\n    {\n        word: &#39;word&#39;,\n        font: &#39;30px Arial&#39;,\n        fontHeight: 30,\n        color: &#39;RGBA(0,0,0,1)&#39;\n    },\n    {\n        word: &#39;cannotthinkofone&#39;,\n        font: &#39;10px Roboto&#39;,\n        fontHeight: 10,\n        color: &#39;RGBA(255,0,0,1)&#39;\n    },\n    // … etc.\n];\n\n// find the width of a word and save it as fillWidth\nvar calculateWidths = function(value, index, array) {\n    context.font = value.font;\n    value.fillWidth = context.measureText(value.word).width;\n};\n\nwordList.map(calculateWidths);</code></pre>\n<h3 id=\"finding-drawing-coordinates\">Finding Drawing Coordinates</h3>\n<p>Steps 2 through 4 were wrapped in a single function to which I could pass the collection of word objects. Within this function, I wanted to loop through the collection and find drawing coordinates for each word. The loop needed to build out a list of occupied spaces on the canvas for each word to be drawn, and this growing list needed to be accessible to each subsequent iteration of the loop. I started with an empty array to store the collection of occupied spaces within the wrapper, then made an occupied space constructor.</p>\n<pre><code>// set-up canvas context, measure words in wordList\n\nvar findDrawingCoordinates = function(array) {\n\n    // the collection of occupied spaces\n    var occupiedZones = [];\n\n    function OccupiedZone(minX, maxX, minY, maxY) {\n        this.minX = minX;\n        this.maxX = maxX;\n        this.minY = minY;\n        this.maxY = maxY;\n    }\n\n    // the rest…\n};</code></pre>\n<p>The next step was to write the function that would loop through the passed array and actually find a location for each word. This point selection function first randomly selects a rotation for the word to be drawn, then randomly selects a starting X and starting Y coordinate from which to draw the selected word. The corners of the rectangular space occupied by the given word are determined by the rotation value. To keep things simple (and clean looking in the final drawn canvas), I limited the possible word rotations to 90 degree increments (excluding upside down words), such that words would either be oriented pointing down, pointed up, or reading LTR. The corner locations and midpoints of each of the four sides of the word’s rectangle are then used to test whether there is overlap between this randomly selected word location and any spaces already occupied by preceding words. To break that down:</p>\n<pre><code>// set-up canvas context, measure words in wordList\n\nvar findDrawingCoordinates = function(array) {\n\n    // occupiedZones code\n\n    // the function that will be used in a forEach for the collection of word objects\n    var selectPoint = function(value, index, array) {\n\n        // the range from which random x and y values are to be selected\n        var SPAN = 100;\n        var dimensionSpan = SPAN;\n\n        // a random rotation, limited to -90, 0, or 90 degrees\n        var rotation = (1 - Math.floor(Math.random() * 3)) * 90;\n\n        // get a new set of test coordinates using a random x and random y\n        var newXY = function(){\n            var randomX = Math.floor((0.5 - Math.random()) * dimensionSpan);\n            var randomY = Math.floor((0.5 - Math.random()) * dimensionSpan);\n            return calculateTestCoordinates(randomX, randomY);\n        };\n\n        // The rotation determines the minimum and maximum values of x and y, because text is\n        // draw on the canvas with the origin at the text&#39;s bottom left. If the canvas is rotated\n        // 90 degrees, that origin is now at the top left, etc.\n        var calculateTestCoordinates(testX, testY) {\n            var testCoords = {};\n\n            testCoords.x = testX;\n            testCoords.y = testY;\n\n            if (rotation === -90) {\n                testCoords.minX = testX - value.fontHeight;\n                testCoords.maxX = testX;\n                testCoords.minY = testY - value.fillWidth;\n                testCoords.maxY = testY;\n            } else if (rotation === 90) {\n                testCoords.minX = testX;\n                testCoords.maxX = testX + value.fontHeight;\n                testCoords.minY = testY;\n                testCoords.maxY = testY + value.fillWidth;\n            } else {\n                testCoords.minX = testX;\n                testCoords.maxX = testX + value.fillWidth;\n                testCoords.minY = testY - value.fontHeight;\n                testCoords.maxY = testY;\n            }\n\n            testCoords.mid1 = { x: testCoords.minX, y: (testCoords.maxY - testCoords.minY) / 2 };\n            testCoords.mid2 = { x: (testCoords.maxX - testCoords.minX) / 2, y: testCoords.minY };\n            testCoords.mid3 = { x: testCoords.maxX, y: (testCoords.maxY - testCoords.minY) / 2 };\n            testCoords.mid4 = { x: (testCoords.maxX - testCoords.minX) / 2, y: testCoords.maxY };\n\n            return testCoords;\n        };\n\n    };\n\n    // the rest…\n};</code></pre>\n<p>The important things to note here are that the rotation is only calculated once, and new test coordinates (which depend on the rotation) can be easily calculated whenever a new random point (random X and random Y coordinates) is selected. The origin for text drawn on a 2d canvas context is the lower left corner of the text string. If the canvas is rotated -90 degrees so that text is read from bottom to top, the origin of the drawn word is now on the bottom right. If rotated 90 degrees, the origin is now on the top left. These differences dictate the disparity in calculating the test coordinates amongst the various rotation values.</p>\n<p>A final step before actually going through and finding an unoccupied space in which to draw a word in the list is to establish a way to add a new occupied space to the collection of occupied zones.</p>\n<pre><code>// set-up canvas context, measure words in wordList\n\nvar findDrawingCoordinates = function(array) {\n\n    // occupiedZones code here\n\n    // the function that will be used in a forEach for the collection of word objects\n    var selectPoint = function(value, index, array) {\n\n        // rotation, newXY, and calculateTestCoordinates code here\n\n        var addOccupiedZone = function(x, y) {\n            if (rotation === -90) {\n                occupiedZones.push(new OccupiedZone(\n                    x - value.fontHeight,\n                    x,\n                    y - value.fillWidth,\n                    y\n                ));\n            } else if (rotation === 90) {\n                occupiedZones.push(new OccupiedZone(\n                    x,\n                    x + value.fontHeight,\n                    y,\n                    y+ value.fillWidth\n                ));\n            } else {\n                occupiedZones.push(new OccupiedZone(\n                    x,\n                    x + value.fillWidth,\n                    y - value.fontHeight,\n                    y\n                ));\n            }\n        };\n\n    };\n\n    // the rest…\n};</code></pre>\n<p>With this structure in place, the loop to test the area occupied by a randomly selected set of coordinates can be set-up.</p>\n<pre><code>// set-up canvas context, measure words in wordList\n\nvar findDrawingCoordinates = function(array) {\n\n    // occupiedZones code\n\n    // the function that will be used in a forEach for the collection of word objects\n    var selectPoint = function(value, index, array) {\n\n        // rotation, newXY, calculateTestCoordinates, and addOccupiedZone code here\n\n        // keep track of how many times testLoop has run for a given word\n        var testIncrementer = 0;\n\n        var testLoop = function() {\n            var testArea = newXY();\n\n            if (occupiedZones.length &gt; 0) {\n\n                for (var i = 0; i &lt; occupiedZones.length; i++) {\n                    if ((testArea.minX &gt; occupiedZones[i].maxX || testArea.minX &lt; occupiedZones[i].minX || testArea.maxY &gt; occupiedZones[i].maxY || testArea.maxY &lt; occupiedZones[i].minY) &amp;&amp;\n                        (testArea.minX &gt; occupiedZones[i].maxX || testArea.minX &lt; occupiedZones[i].minX || testArea.minY &gt; occupiedZones[i].maxY || testArea.minY &lt; occupiedZones[i].minY) &amp;&amp;\n                        (testArea.maxX &gt; occupiedZones[i].maxX || testArea.maxX &lt; occupiedZones[i].minX || testArea.maxY &gt; occupiedZones[i].maxY || testArea.maxY &lt; occupiedZones[i].minY) &amp;&amp;\n                        (testArea.maxX &gt; occupiedZones[i].maxX || testArea.maxX &lt; occupiedZones[i].minX || testArea.minY &gt; occupiedZones[i].maxY || testArea.minY &lt; occupiedZones[i].minY) &amp;&amp;\n                        (testArea.mid1.x &gt; occupiedZones[i].maxX || testArea.mid1.x &lt; occupiedZones[i].minX || testArea.mid1.y &gt; occupiedZones[i].maxY || testArea.mid1.y &lt; occupiedZones[i].minY) &amp;&amp;\n                        (testArea.mid2.x &gt; occupiedZones[i].maxX || testArea.mid2.x &lt; occupiedZones[i].minX || testArea.mid2.y &gt; occupiedZones[i].maxY || testArea.mid2.y &lt; occupiedZones[i].minY) &amp;&amp;\n                        (testArea.mid3.x &gt; occupiedZones[i].maxX || testArea.mid3.x &lt; occupiedZones[i].minX || testArea.mid3.y &gt; occupiedZones[i].maxY || testArea.mid3.y &lt; occupiedZones[i].minY) &amp;&amp;\n                        (testArea.mid4.x &gt; occupiedZones[i].maxX || testArea.mid4.x &lt; occupiedZones[i].minX || testArea.mid4.y &gt; occupiedZones[i].maxY || testArea.mid4.y &lt; occupiedZones[i].minY)\n                    ) {\n                        if (i === occupiedZones.length - 1) {\n                            value.xCoord = testArea.x;\n                            value.yCoord = testArea.y;\n                            value.rotation = rotation;\n                            addOccupideZone(testArea.x, testArea.y);\n                            dimensionSpan = SPAN;\n                            break;\n                        } else {\n                            continue;\n                        }\n                    } else {\n                        testIncrementer++;\n\n                        // if the test loop is run 500 times without success, increase the range from which random\n                        // values of x and y are being selected\n                        if (testIncrementer &gt;= 500) {\n                            dimensionSpan += 10;\n                            testIncrementer = 0;\n                        }\n                        return testLoop();\n                    }\n                }\n\n            } else {\n                value.xCoord = testArea.x;\n                value.yCoord = testArea.y;\n                value.rotation = rotation;\n                addOccupiedZone(testArea.x, testArea.y);\n            }\n        };\n\n        testLoop();\n    };\n\n    // the rest\n};</code></pre>\n<p>This is the meat of the code right here. If there aren’t any occupied zones defined (<code>occupiedZones.length === 0</code>), the selected rotation, x, and y are assigned to the current word object being iterated over in the collection, and the rectangular space that will be occupied by this word is added to the <code>occupiedZones</code> array. If there are occupied zones defined, however, the selected rotation, x, and y for the current value are tested to see if they will cause an overlap with any previously defined occupied zones. If an overlap is detected, <code>testLoop()</code> is called again for the current word object. This process is repeated until a suitable point from which to draw is found. Once such a point is found, the area that will be occupied by the word when drawn from this point is added to the <code>occupiedZones</code> collection to be tested against for the next word object in the <code>wordList</code> collection.</p>\n<p>Now the point selection can actually be performed for the list of words:</p>\n<pre><code>// set-up canvas context, measure words in wordList\n\nvar findDrawingCoordinates = function(array) {\n\n    // occupiedZones code\n    // selectPoint code\n\n    array.forEach(selectPoint);\n\n    // the rest\n};</code></pre>\n<h3 id=\"canvas-size-and-origin\">Canvas Size and Origin</h3>\n<p>The final step before drawing is to glean some additional info from the <code>occupiedZones</code> array to help set up the canvas. The minimum X and Y are used to determine the origin of the canvas, and those values along with the maximum X and Y are used to calculate the canvas dimensions. Finding these four values can be achieved with a series of sorts on the occupiedZones collection.</p>\n<pre><code>// set-up canvas context, measure words in wordList\n\nvar findDrawingCoordinates = function(array) {\n\n    // occupiedZones code\n    // selectPoint code\n\n    array.forEach(selectPoint);\n\n    // find smallest x in occupied area\n    occupiedZones.sort(function(a, b) { return a.minX - b.minX; });\n    var xCanvasOrigin = Math.floor(occupiedZones[0].minX);\n\n    // find smallest y in occupied area\n    occupiedZones.sort(function(a, b){ return a.minY - b.minY; });\n    var yCanvasOrigin = Math.floor(occupiedZones[0].minY);\n\n    // find largest x, calculate width of canvas\n    occupiedZones.sort(function(a, b){ return b.maxX - a.maxX; });\n    var canvasWidth = Math.ceil(occupiedZones[0].maxX) - xCanvasOrigin;\n\n    // find largest y, calculate height of canvas\n    occupiedZones.sort(function(a, b){ return b.maxY - a.maxY; });\n    var canvasHeight = Math.ceil(occupiedZones[0].maxY) - yCanvasOrigin;\n\n    canvasDimensions = {\n        minX: xCanvasOrigin,\n        minY: yCanvasOrigin,\n        width: canvasWidth,\n        height: canvasHeight\n    };\n\n    return array;\n};</code></pre>\n<h3 id=\"drawing-the-words\">Drawing the Words</h3>\n<p>Finally, everything needed has been collected, and step 5 &mdash; drawing the words on the canvas &mdash; can be tackled. This part consists of a function which will accept the <code>wordList</code> collection from earlier and the <code>canvasDimensions</code> object as arguments. Within this wrapper will be a function for drawing individual words, which will again be used to loop through the <code>wordList</code> array.</p>\n<pre><code>// set-up canvas context, measure words in wordList\n// findDrawingCoordinates code\n\nvar drawWordCloud = function(wordArray, canvasSizingObject) {\n\n    var drawWord = function(word) {\n        context.translate(word.xCoord, word.yCoord);\n        context.rotate(word.rotation * Math.PI / 180);\n        context.font = word.font;\n        context.fillStyle = word.color;\n        context.fillText(word.word, 0, 0);\n        context.rotate(-(word.rotation) * Math.PI / 180); // un-rotate the context\n        context.translate(-(word.xCoord), -(word.yCoord)); // un-translate the context\n    };\n\n    var xTranslation = Math.abs(canvasSizingObject.minX) + 5; // add a little padding to the canvas\n    var yTranslation = Math.abs(canvasSizingObject.minY) + 5;\n\n    canvas.height = canvasSizingObject.height + 10;\n    canvas.width = canvasSizingObject.width + 10;\n\n    context.translate(xTranslation, yTranslation);\n    wordArray.forEach(drawWord);\n};</code></pre>\n<p>And last but not least, the collection of word objects can be passed into the written functions, finding the location for each word and drawing the whole collection to the canvas, hopefully with a minimum of overlap!</p>\n<pre><code>// set-up canvas context, measure words in wordList\n// findDrawingCoordinates code\n// drawWordCloud code\n\nvar drawingCoordinates = findDrawingCoordinates(wordList);\ndrawWordCloud(drawingCoordinates, canvasDimensions);</code></pre>\n<h3 id=\"closing-thoughts\">Closing Thoughts</h3>\n<p>After putting this together in <a href=\"http://www.benjanes.com/WordCloud/\">an app</a>, I allowed myself to look for other (better) techniques for doing this. <code>getImageData</code> seems to be the way to go for looking for pixel-level overlaps in drawing space. However, looking through individual pixels could be a very expensive process. Adapting a technique like the one I implemented above can help to narrow down the area in which pixels are being checked.</p>\n<p>Check out <a href=\"http://chimera.labs.oreilly.com/books/1234000001654/ch04.html#using_pixel_data_to_detect_object_collis\">O&#39;Reilly&#39;s canvas book section</a> on the topic. Also check out Timothy Guan-tin Chien&#39;s <a href=\"https://github.com/timdream/wordcloud\">HTML5 Word Cloud</a>.</p>","meta":{"year":"2015","month":"09","day":"08","filename":"drawing-in-unoccupied-space","title":"Drawing in Unoccupied Space","date":"2015-09-08T12:00:00.000Z","desc":"Drawing words randomly on a canvas without overlap.","tags":["canvas","JavaScript","algorithms","HTML5"]}}