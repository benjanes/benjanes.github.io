{"content":"<p>I&#39;ve been using <code>Function.prototype.apply</code> and <code>Function.prototype.call</code> for a while now. I remember when I was reading about them on MDN for the first time. I looked at <code>.apply</code> and said, &quot;Why would I ever use this, I can pass in my arguments individually to <code>.call</code> without having to put them into an array!&quot; Not long after, I said something along the lines of, &quot;Oh yeah, <code>arguments</code>!!&quot;</p>\n<p>At the same time I was first learning about <code>.apply</code> and <code>.call</code>, I read up on <code>.bind</code>. I couldn&#39;t for the life of me determine why I would ever want to use <code>.bind</code> when I could just use <code>.call</code>. Because of this, I pushed <code>.bind</code> off to the side and tried to forget about it. Well, I just had my &quot;<code>.bind</code> aha moment&quot;. It is awesome. And it was there right under my nose in the first line of the MDN description the whole time. To quote <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind\">MDN</a> (emphasis added):</p>\n<blockquote>\n<p>The bind() method <strong>creates a new function</strong> that, when called, has its this keyword set to the provided value, with a given sequence of arguments preceding any provided when the new function is called.</p>\n</blockquote>\n<p>The big difference between <code>.bind</code> and those other two Function prototype methods is that <code>.bind</code> returns a function. That returned function essentially serves as a wrapper for calling <code>.apply</code>, such that the context you want for your outer function is hard bound. The potential for any binding ambiguity provided by <code>.apply</code> or <code>.call</code> is no longer an issue. What&#39;s more, because a function is returned, you can use <code>.bind</code> to specify the context in a callback function!</p>\n<p>To illustrate:</p>\n<pre><code>var myObj = { x : 1 };\n\nvar addToX = function() {\n  this.x++\n};\n\n// if we call addToX in the global context, nothing happens \n// --&gt; x is not defined in the global context\naddToX();\n\n// console.log(myObj.x) --&gt; 1\n// console.log(x) --&gt; NaN\n\n// if we use .call to bind myObj to addToX, \n// we get x to increment in addToX\naddToX.bind(myObj);\n\n// console.log(myObj.x) --&gt; 2\n\n// now if we try to use .call in a callback, we are invoking \n// it as soon as the setTimeout is encountered, **not after \n// 500 milliseconds**. what is actually getting passed to \n// setTimeout is the return value for .call (undefined) and the \n// wait value (500)\nsetTimeout( addToX.call(myObj), 500);\n\n// console.log(myObj.x) --&gt; 3 \n// ... but it didn&#39;t happen when we wanted it to\n\n// we can get around this issue by passing a function to be \n// run by setTimeout which will in turn invoke .call\nsetTimeout( function() {\n  addToX.call(myObj);\n}, 500);\n\n// console.log(myObj.x) --&gt; 4 \n// ... and it happened when we wanted it to!\n\n// but wait, we can simplify just a bit with our friend .bind! \n// we take advantage of the fact that .bind returns a function\nsetTimeout( addToX.bind(myObj), 500);\n\n// console.log(myObj.x) --&gt; 5 \n// ... proper binding, when we want it\n// ... and we didn&#39;t need to wrap it in an anonymous function</code></pre>","meta":{"year":"2016","month":"03","day":"05","filename":"the-long-way-to-hard-binding","title":"The Long Way to Hard Binding","date":"2016-03-05T12:00:00.000Z","desc":"Hard binding using Function.prototype.bind","tags":["JavaScript","JS Fundamentals","keyword this","execution context"]}}