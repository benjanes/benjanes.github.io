{"content":"<p>Generators in ES6 provide a way to lazily evaluate a function. Say we start to execute a generator function and then exit out of it. Normally (<em>e.g.</em>, in the case of a <code>return</code> statement in a function) this would mean that we are done with this function. In the case of a generator, at some later point we can re-enter the generator function where we left off and evaluate the next part.</p>\n<p>This gives us another tool for handling asynchronous code. When we combine the powers of generators with those of promises, we end up being able to write code that <em>looks synchronous</em> but gets evaluated asynchronously. In other words, we can write asynchronous code that looks really nice! I will get to that in the next post, but for now let&#39;s explore how generator functions work.</p>\n<p>Generator functions are declared using <code>*</code> as either <code>function* myFunc(){}</code> or <code>function *myFunc(){}</code>. When a generator function is called, the function itself isn&#39;t executed at all. Instead, an iterator object is returned. To evaluate the generator function, we call <code>.next</code> on the returned iterator. When we call <code>.next</code>, what happens is:</p>\n<ol>\n<li>The generator function is evaluated up to the first <code>yield</code> statement, </li>\n<li>This returns an object and pops the control flow out of the generator,</li>\n<li>The control flow returns to the point in the code at which <code>.next</code> was called. </li>\n</ol>\n<p>The object returned when calling <code>.next</code> has a <code>.value</code> property and a <code>.done</code> property. The <code>.value</code> property is equal to the the evaluation of the expression directly after the <code>yield</code> statement (on the same line), just like a <code>return</code> statment. The <code>.done</code> property is a boolean that indicates if the end of the generator function has been reached. The next time that we call <code>.next</code> on the iterator object, evaluation of the generator object will pick up where it left off and go until the next <code>yield</code> statement is reached.</p>\n<pre><code>// let&#39;s make a simple generator function\nfunction *myGenerator(x, y, z) {\n  yield x;                    // line1\n  y += x;                     // line2\n  yield y;                    // line3\n  z += y;                     // line4\n  yield z;                    // line5\n  return &#39;now we are done&#39;;   // line6\n}\n\n// when we invoke myGenerator, it will return an iterator object...\n// so let&#39;s assign that object to a variable so we can work with it\nvar myGenIterator = myGenerator(5, 10, 20);\n\n// when we call .next on myGenIterator, we evaluate only as far as\n// the first yield statement, on line1. this yield statement does\n// 2 things. it pops the control flow out of the generator, and it\n// returns an object.\nvar firstYield = myGenIterator.next();\n\n// if we look at the object returned by .next, we&#39;ll see that it\n// has two properties: .value and .done\nconsole.log(firstYield); // --&gt; logs { value : 5, done : false }\n\n// now if we call .next again, we will evaluate the generator as \n// far as the yield statement on line3\n// before the yield statement, the code on line2 will execute, so \n// the yield will return a value of y + x\nvar secondYield = myGenIterator.next().value;\nconsole.log(secondYield); // --&gt; logs 15\n\n// on the next call of .next, we evaluate line4 and then hit the\n// last yield on line5. you might expect that, because this is \n// the last yield in the generator, the returned object&#39;s .done\n// property would be set to true. however, .done is relative to \n// the generator function body, not the yield statements themselves\n// ... calling .next on the iterator object won&#39;t return an object\n// with .done === true until we hit a return statement or \n// the end of the generator function&#39;s body (the ending curly brace)\nvar thirdYield = myGenIterator.next();\nconsole.log(thirdYield.value); // --&gt; logs 35\nconsole.log(thirdYield.done); // --&gt; logs false\n\n// on the next .next call, we reach the end of the generator. if\n// we want to pass a value to the object returned by calling .next,\n// we can do so using a return statement in the generator, which\n// we have done on line6\nvar lastYield = myGenIterator.next();\nconsole.log(lastYield.value); // --&gt; logs &#39;now we are done&#39;\nconsole.log(lastYield.done); // --&gt; logs true\n\n// now that we&#39;ve reached the end of the generator, we can call\n// .next on the iterator object all we want. but it will always\n// return the same thing:\nvar oneMoreYield = myGenIterator.next();\nconsole.log(oneMoreYield); // --&gt; logs {value: undefined, done: true}</code></pre>\n<p>Next time: combining generators and promises with <code>q.spawn</code>.</p>","meta":{"year":"2016","month":"03","day":"30","filename":"es6-generators","title":"Generator Functions","date":"2016-03-30T12:00:00.000Z","desc":"The basics on ES6 generators.","tags":["JavaScript","Generator function","ES6","ES6 Generator"]}}