{"content":"<p>I&#39;ve been having a blast working my way through the excellent <a href=\"http://learnyouahaskell.com/\">Learn You a Haskell for Great Good</a> in my spare time. I don&#39;t know that I&#39;ll ever take my Haskell skills beyond the realm of toy problems, but the process of learning the language has already had an impact on how I think about writing Javascript, the main language that I use at work. I&#39;d like to use this space to record first impressions of some of the fundamentals of Haskell (and perhaps of functional programming in general), and how these concepts map to Javascript.</p>\n<p>The first thing I noticed when looking at Haskell type definitions (already a foreign concept for anyone who has JS as their first language) was... a lot of arrows. &quot;That&#39;s a lot of function returns for one simple function,&quot; I thought. Take for example this function that adds 3 integers:</p>\n<pre><code>addThreeInts :: Int -&gt; Int -&gt; Int -&gt; Int\naddThreeInts a b c = a + b + c</code></pre>\n<p>When we define <code>addThreeInts</code> we place the type signature after the double colon, then supply the function itself below. So the type signature is <code>Int -&gt; Int -&gt; Int -&gt; Int</code>. This indicates that the function <code>addThreeInts</code> takes an <code>Int</code> and returns a function that takes an <code>Int</code> which returns a function that takes an <code>Int</code> which returns an <code>Int</code>. Why then does the function definition look like it takes three arguments and has a single return? In Javascript, the same function would look like:</p>\n<pre><code>function addThreeInts(a, b, c) {\n  return a + b + c;\n}</code></pre>\n<p>Notice that the definitions look very similar. But, we still have that weird type signature. The Haskell type signature written as it is helps to drive home this point: everything is curried in Haskell! Functions can only ever accept one argument. If you write a function that is not unary, intermediate steps in applying arguments to that function will be returned functions. So when we call <code>addThreeInts</code> with one integer, <code>a</code>, what gets returned is a function. This function would have the type signature <code>Int -&gt; Int -&gt; Int</code>. Pass another <code>Int</code>, <code>b</code>, to this function, and the return value will be another function with type <code>Int -&gt; Int</code>. In these intermediate steps, <code>a</code> and <code>b</code> are being applied to <code>addThreeInts</code> and we&#39;re returning a partially applied function. Pass a third integer, <code>c</code>, and we get the result of <code>a + b + c</code>.</p>\n<p>Well, this is awesome. If we pass a single argument to this function as written in JS, we&#39;d get a return value of <code>NaN</code> as we would be trying to add an integer to two <code>undefined</code>s. Of course, we can rewrite <code>addThreeInts</code> so that it is curried:</p>\n<pre><code>function addThreeInts(a) {\n  return function(b) {\n    return function(c) {\n      return a + b + c;\n    }\n  }\n}</code></pre>\n<p>This looks kind of ugly in ES5. In ES6, it starts to really resemble our Haskell type signature:</p>\n<pre><code>const addThreeInts = a =&gt; b =&gt; c =&gt; a + b + c;</code></pre>\n<p>The big difference here is that we had to change our function to make it curry. In Haskell, there isn&#39;t anyway around currying, as every function must be unary!</p>","meta":{"year":"2017","month":"01","day":"20","filename":"haskell-nuggets-one","title":"Haskell Nugget: Everything Curried","date":"2017-01-20T12:00:00.000Z","desc":"A basic concept in Haskell is that all functions are curried","tags":["Haskell","currying","Javascript","Functional Programming"]}}