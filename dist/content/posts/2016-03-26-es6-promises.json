{"content":"<p>My <a href=\"/2016/03/24/basic-promises\">last post</a> was a brief intro to creating promises with <code>q.defer</code>. ES6 incorporates a native <code>Promise</code> object that can be used to the same end. If you&#39;d like to <em>promisify</em> an async function, return an instance of the <code>Promise</code> object from that function. The <code>Promise</code> constructor takes a callback (referred to as an &quot;executor&quot; function), which in turn takes <code>resolve</code> and <code>reject</code> callbacks. The body of the callback passed to the <code>Promise</code> constructor contains the functionality of the original async function, with return values getting passed to either the <code>resolve</code> (in the case of successful resolution) or <code>reject</code>. This is a lot clearer in code.</p>\n<pre><code>// say we are working in node with an async function, e.g. \n// fs.readFile...\n// if we were writing a function to do something with an \n// input, then pass the output from fs.readFile to a callback \n// (the standard callback set-up), it would look something \n// like this:\nfunction doSomething(myInput, callback) {\n  fs.readFile(myInput, function(err, body) {\n    if (err) {\n      callback(err);\n    } else {\n      callback(err, body.toString(&#39;utf8&#39;));\n    }\n  });\n}\n\n// to switch this function to the promise pattern, we want \n// to be returning an instance of the promise object. instead \n// of passing the err and body values to a callback, we will \n// pass them to our resolve and reject functions that are \n// passed in as arguments to the promise&#39;s &quot;executor&quot; function\nfunction doSomethingPromisey(myInput) {\n  return new Promise(function(resolve, reject) {\n    fs.readFile(myInput, function(err, body) {\n      if (err) {\n        reject(err);\n      } else {\n        // it is important to note here that the reject and\n        // resolve functions can only take and pass a single \n        // value. if you want to keep a value from higher up\n        // in a chain in scope, you either need to do some\n        // nesting or pass that value directly in a resolve\n        // (you could pass multiple values in an object\n        // literal, for instance)\n        resolve(body.toString(&#39;utf8&#39;));\n      }\n    });\n  });\n}\n\n// now when doSomethingPromisey gets called, it returns a \n// promise that will at some point be resolved or rejected.</code></pre>\n<p>This is what the code from the last post looks like when we switch it over from using <code>q.defer</code> to the ES6 <code>Promise</code> object:</p>\n<pre><code>// the one difference here from the last post is that there\n// is some error handling incorporated into the promises. if\n// a reject is called at any point within a chain of .then&#39;s, \n// the remainder of that .then chain is skipped over until the\n// .catch is reached. (see below where these functions are\n// invoked)\nfunction asyncAdd10(x) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      if (typeof x !== &#39;number&#39;) {\n        reject(NaN);\n      } else {\n        resolve(x + 10);\n      }\n    }, 1000);\n  });\n}\n\nfunction asyncMultiply3(x) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      if (typeof x !== &#39;number&#39;) {\n        reject(NaN);\n      } else {\n        resolve(x * 3);\n      }\n    }, 1000);\n  });\n}\n\nfunction asyncDivideBy5(x) {\n  return new Promise(function(resolve, reject) {\n    setTimeout(function() {\n      if (typeof x !== &#39;number&#39;) {\n        reject(NaN);\n      } else {\n        resolve(x / 5);\n      }\n    }, 1000);\n  });\n}\n\n// if we pass 10, 12 will get logged to the console after\n// 3 seconds.\nasyncAdd10(10).then(function(val) {\n  return asyncMultiply3(val);\n}).then(function(val) {\n  return asyncDivideBy5(val);\n}).then(function(val) {\n  console.log(val);\n}).catch(function(err) {\n  console.log(err);\n});\n\n// however, if we pass a string, we will skip to the .catch\n// as soon as that first reject function is called. so after\n// one second, NaN will get logged to the console\nasyncAdd10(&#39;I am not a number&#39;).then(function(val) {\n  return asyncMultiply3(val);\n}).then(function(val) {\n  return asyncDivideBy5(val);\n}).then(function(val) {\n  console.log(val);\n}).catch(function(err) {\n  console.log(err);\n});</code></pre>","meta":{"year":"2016","month":"03","day":"26","filename":"es6-promises","title":"ES6 Flavored Promises","date":"2016-03-25T12:00:00.000Z","desc":"Using the native Promise object in ES6.","tags":["JavaScript","Promises","ES6","ES6 Promise"]}}